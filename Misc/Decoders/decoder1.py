# -*- coding: utf-8 -*-
"""Decoder1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13PybJGk7DWgR0QnRgVuy4li6a2rZR5sk
"""



import cv2
import numpy as np
import matplotlib.pyplot as plt

#1#imporing image and making it black and white // and ploting it
img = cv2.imread("/content/emad99.png", cv2.IMREAD_GRAYSCALE)
_, img = cv2.threshold(img, 128, 255, cv2.THRESH_BINARY)
fig = plt.figure(figsize=(5, 5));
plt.xticks([], []);
plt.yticks([], []);
plt.title('Example QR code')
plt.imshow(img, cmap='gray');

#2#reading queit zone // reading where is the white part that surrounds QR code and indicating the boundaries of the QR code
start_row = -1
start_col = -1
end_row = -1
end_col = -1

for row_index, row in enumerate(img):
    for pixel in row:
        if pixel != 255:
            start_row = row_index
            break
    if start_row != -1:
        break

for row_index, row in enumerate(img[::-1]):
    for pixel in row:
        if pixel != 255:
            end_row = img.shape[0] - row_index
            break
    if end_row != -1:
        break

for col_index, col in enumerate(cv2.transpose(img)):
    for pixel in col:
        if pixel != 255:
            start_col = col_index
            break
    if start_col != -1:
        break

for col_index, col in enumerate(cv2.transpose(img)[::-1]):
    for pixel in col:
        if pixel != 255:
            end_col = img.shape[1] - col_index
            break
    if end_col != -1:
        break

print("boundaries of QR code are:", start_row, end_row, start_col, end_col)


#3#taking the indicated boundaries of the QR code plotting it, removing all white space surrounding it
qr_no_quiet_zone = img[start_row:end_row, start_col:end_col]
fig = plt.figure(figsize=(5, 5));
plt.xticks([], []);
plt.yticks([], []);
fig.get_axes()[0].spines[:].set_color('red');
fig.get_axes()[0].spines[:].set_linewidth(40);
fig.get_axes()[0].spines[:].set_position(("outward", 20))
plt.title('QR code without quiet zone', y = 1.15, color='red');
plt.imshow(qr_no_quiet_zone, cmap='gray');

# calculating dimensions of the QR code without the quiet zone (.shape get dimensions of the array)
print("Dimensions of the QR code without QZ:",qr_no_quiet_zone.shape)

#calculate grid's cell size by starting from top-left pixel moving to the right and counting number of black pixels
#till we meet first white pixel we stop count ... then, (size of cell = (BlackPixelsCount/7))
#as this version of QR code have 7x7 locator box (3 main boxes)
# size = 0
# for pixel in qr_no_quiet_zone[0]:
#     if (pixel != 0): break
#     size += 1
#print("BlackPixelCount is :", size)
# Therefore the grid cell size is..
# grid_cell_size = round(size/7)
# print("Grid pixel size is:",grid_cell_size)
#Take the QR code without quiet zone, and divide it by size of cell calculated before for grid
#so now we have number of grid cells that this QR code wil be splitted to
# grid_cells_num = round(qr_no_quiet_zone.shape[0]/grid_cell_size)
# print("Number of cells in grid in 1 dimension:",grid_cells_num)
# calculating dimensions of the QR code without the quiet zone (.shape get dimensions of the array)
#print("Dimensions of the QR code without QZ:",qr_no_quiet_zone.shape)


#using this QR code version, the qr have 21 unique square in each dimension .. so we'll make grid of 21x21 cell

grid_cells_num = 21

#check if qr code dimensions without QZ is square , if not make it square

if qr_no_quiet_zone.shape[0]==qr_no_quiet_zone.shape[1]:
  newsize = qr_no_quiet_zone.shape[0]
else:
  newsize = max(qr_no_quiet_zone.shape[0], qr_no_quiet_zone.shape[1])
  #ensure that the new size is multiple of 21:
  newsize = grid_cells_num * np.ceil(newsize / grid_cells_num).astype(int)
  qr_no_quiet_zone = cv2.resize(qr_no_quiet_zone,(newsize, newsize))

grid_cell_size= newsize//grid_cells_num

print("Dimensions of the QR code after resizing:",qr_no_quiet_zone.shape)


#now we grid the QR code into small boxes using .reshape
#grid_cells_num: number of rows and cols of the small boxes
#grid_cell_size: size of each small box
#.swapaxes : arrange the splitted small boxes correctly and aligned like the original QR code
qr_cells = qr_no_quiet_zone.reshape((
    grid_cells_num,
    grid_cell_size,
    grid_cells_num,
    grid_cell_size,
)).swapaxes(1, 2)
print(qr_cells.shape)


#plot the QR in small boxes each box framed in red frame
_, axes = plt.subplots(grid_cells_num, grid_cells_num, figsize=(5, 5))
for i, row in enumerate(axes):
    for j, col in enumerate(row):
        col.imshow(qr_cells[i][j], cmap="gray", vmin=0, vmax=255)
        col.get_xaxis().set_visible(False)
        col.get_yaxis().set_visible(False)
        col.spines[:].set_color('red')